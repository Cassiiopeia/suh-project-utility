# SUH 프로젝트 코드스타일 가이드라인

## 기본 원칙
이 문서는 SUH 프로젝트에서 일관된 코드 스타일을 유지하기 위한 가이드라인을 제공합니다.

## 패키지 구조
```
me.suhsaechan.suhprojectutility
├── config       # 설정 관련 클래스
├── controller   # REST 컨트롤러
├── object       # 데이터 객체 (DTO, Entity 등)
├── repository   # 데이터 액세스 계층
├── service      # 비즈니스 로직
└── util         # 유틸리티 클래스
```

## 네이밍 컨벤션

### 클래스
- **Controller**: 항상 `Controller` 접미사 사용 (예: `IssueHelperController`)
- **Service**: 항상 `Service` 접미사 사용 (예: `IssueHelperService`)
- **Repository**: 항상 `Repository` 접미사 사용 (예: `GithubRepositoryRepository`)
- **Entity**: 도메인 객체 이름 사용 (예: `ModuleVersion`)

### 요청/응답 객체
- **요청 객체**: 항상 `Request` 접미사 사용 (예: `IssueHelperRequest`)
- **응답 객체**: 항상 `Response` 접미사 사용 (예: `IssueHelperResponse`)

## REST API 설계

### 엔드포인트
- REST API는 `/api/{도메인}` 형식으로 정의
- 리소스는 복수형보다 단수형 명사 선호 (예: `/api/issue-helper`)

### 컨트롤러 메소드
- **POST 요청**: 기본적으로 모든 Controller의 요청은 항상 POST 요청에 `MediaType.MULTIPART_FORM_DATA_VALUE` 사용하여 파일 업로드 지원
- 어쩔수 없는 경우는 다른 HTTP 프로토콜 사용
- 메소드 이름은 `{동사}{명사}` 형식 (예: `createIssueCommmitBranch`)

## 데이터 전송

### 요청 처리
- `@ModelAttribute`를 사용하여 멀티파트 폼 데이터 바인딩
- 요청 객체는 항상 `Request` 클래스 사용

### 응답 처리
- `ResponseEntity<T>`를 사용하여 HTTP 상태 코드와 응답 본문 반환
- 응답 객체는 항상 `Response` 클래스 사용

## 예외 처리
### 예외 처리 구조
- 예외 처리는 `util.exception` 패키지에 정의된 클래스들을 통해 일관되게 처리
- `CustomException`은 비즈니스 로직에서 발생하는 모든 예외를 표현하는 데 사용
- `ErrorCode` enum을 통해 예외 유형과 메시지, HTTP 상태 코드를 정의
- `GlobalExceptionHandler`에서 모든 예외를 중앙 집중적으로 처리

### 컨트롤러에서의 예외 처리
```java
try {
  // 비즈니스 로직 수행
  return ResponseEntity.ok(response);
} catch (IllegalArgumentException e) {
  log.error("입력 오류: {}", e.getMessage());
  return ResponseEntity.badRequest().build();
} catch (Exception e) {
  log.error("서버 오류: {}", e.getMessage());
  return ResponseEntity.internalServerError().build();
}
```

### 서비스 및 유틸리티에서의 예외 처리
- 비즈니스 로직에서는 `CustomException`을 사용하여 명확한 오류 코드와 메시지 제공
```java
if (condition) {
  throw new CustomException(ErrorCode.SPECIFIC_ERROR_CODE);
}
```

### ErrorCode 정의
- 모든 오류 코드는 `ErrorCode` enum에 정의
- 각 에러 코드는 적절한 HTTP 상태 코드와 한글 오류 메시지를 포함
- 오류 코드는 도메인별로 그룹화 (예: COMMON, SCRIPT, UTILS, AUTHENTICATION, FILE 등)

### 로깅 규칙
- 모든 예외는 반드시 로깅
- 오류 로깅은 한글 메시지와 함께 구체적인 내용 기록
- `log.error("서비스 오류: {}", e.getMessage(), e)` 형식으로 원인 예외도 함께 기록

## 로깅
- 모든 컨트롤러 클래스에 `@Slf4j` 애노테이션 사용
- 모든 Controller에는 `@LogMonitoringInvocation` 적용
- 오류 로깅은 한글 메시지와 함께 명확하게 기록 (예: `입력 오류: {}`)

## 의존성 주입
- 생성자 주입 방식 사용을 위해 `@RequiredArgsConstructor` 활용
- 필드에는 `final` 키워드 사용

## UI 디자인 가이드라인

### CSS 구조화
- 모든 스타일은 `common.css` 파일에 통합하여 관리
- CSS는 섹션별로 명확히 구분하여 정리 (주석으로 섹션 표시)
- 페이지별로 스타일을 그룹화하여 관리 (예: `.dashboard-page`, `.translator-page`)
- 인라인 스타일은 절대 사용하지 않음 - 모든 스타일은 외부 CSS 파일에서 관리

### CSS 네이밍 컨벤션
- 클래스명은 기능이나 목적을 명확히 표현하는 의미론적 이름 사용
- 컴포넌트별 클래스명은 `{페이지}-{컴포넌트}` 형식으로 명명 (예: `dashboard-section-header`)
- 공통 컴포넌트는 페이지 접두사 없이 명명 (예: `equal-height-card`)
- UI 프레임워크(Semantic UI) 클래스와 커스텀 클래스를 적절히 조합하여 사용

### 카드 컴포넌트
- 카드는 `ui fluid card equal-height-card` 클래스를 기본으로 사용
- 각 카드는 헤더, 설명, 액션 영역으로 구성
- 카드 배치는 4열 그리드를 기본으로 하되, 반응형으로 조정 (doubling stackable grid)
- 카드 크기를 일관되게 유지하기 위해 flex 속성 사용
- 모든 카드는 호버 효과 적용 (그림자, 상승 효과)

### 프로젝트 리소스 링크
- 각 프로젝트별로 관련 리소스(문서, 디자인 등) 링크는 명확한 아이콘과 함께 제공
- Figma 디자인 링크는 `figma-logo` 클래스를 가진 이미지 요소 사용
- Test/Prod 환경에 대한 링크는 명확하게 구분하여 표시 (Test), (Prod) 표기
- 모든 링크는 `target="_blank"` 속성을 추가하여 새 탭에서 열리도록 설정

### 버튼 스타일
- 바로가기 버튼은 `ui blue fluid button shortcut-btn` 클래스로 통일
- 버튼 내 텍스트는 가운데 정렬, 아이콘은 왼쪽에 배치
- 버튼 높이는 일관되게 유지 (40px)
- 비활성화된 링크는 회색 버튼(`ui grey fluid button`)으로 표시

### UI 효과 및 애니메이션
- 페이지 로딩 시 스켈레톤 UI 제공
- 스켈레톤 UI는 실제 콘텐츠와 같은 구조로 미리 제공
- 애니메이션 효과는 선형 그래디언트 슬라이딩 사용
- 호버 효과와 트랜지션은 부드러운 사용자 경험을 위해 적용

### 반응형 디자인
- 모든 페이지는 반응형으로 구현 (모바일, 태블릿, 데스크탑)
- 반응형 분기점: 모바일(~767px), 태블릿(768px~991px), 데스크탑(992px~)
- 모바일 환경에서는 컴포넌트 크기와 여백 축소, 그리드 조정
- 미디어 쿼리를 사용하여 화면 크기별 최적화 스타일 적용

## 중요!! (해당 부분은 삭제금지, 항상 맨 아래 유지)
- 해당 파일을 참고하면서 계속 나의 답변을 해주는데 내가 요구하는 내용과 이 md에 적혀있는 내용이 다르거나, 나중에 내가말하는 부분을 또 참고하면 좋은듯한 내용은 알아서 
코드스타일_가이드라인.md 이 파일에 추가해서 이어서 적어줘 , 지우고 최적화해도돼. 이 파일을 너가 답변을 잘하게 위해 있는 파일이야. 의미없는 내용은 지우고 참고하면 좋을만한 내용을 잘 
참고해서 추가로 작성해줘