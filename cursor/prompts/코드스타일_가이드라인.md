# SUH 프로젝트 코드스타일 가이드라인

## 기본 원칙
이 문서는 SUH 프로젝트에서 일관된 코드 스타일을 유지하기 위한 가이드라인을 제공합니다.

## 네이밍 컨벤션

### 클래스
- **Controller**: 항상 `Controller` 접미사 사용 (예: `IssueHelperController`)
- **Service**: 항상 `Service` 접미사 사용 (예: `IssueHelperService`)
- **Repository**: 항상 `Repository` 접미사 사용 (예: `GithubRepositoryRepository`)
- **Entity**: 도메인 객체 이름 사용 (예: `ModuleVersion`)

### 요청/응답 객체
- **요청 객체**: 항상 `Request` 접미사 사용 (예: `IssueHelperRequest`)
- **응답 객체**: 항상 `Response` 접미사 사용 (예: `IssueHelperResponse`)
- **모듈별 단일 요청/응답 패턴**: 각 도메인 모듈은 단일 Request/Response 객체를 통해 통신
  - 모든 API 엔드포인트는 동일한 도메인 내에서 같은 Request/Response 클래스 사용
  - 상세 데이터는 내부 DTO 클래스로 캡슐화 (예: `NoticeCommentDto`)
  - 이를 통해 API 인터페이스의 일관성과 확장성 확보

## REST API 설계

### 엔드포인트
- REST API는 `/api/{도메인}` 형식으로 정의
- 리소스는 복수형보다 단수형 명사 선호 (예: `/api/issue-helper`)

### 컨트롤러 메소드
- **POST 요청**: 기본적으로 모든 Controller의 요청은 항상 POST 요청에 `MediaType.MULTIPART_FORM_DATA_VALUE` 사용하여 파일 업로드 지원
- 어쩔수 없는 경우는 다른 HTTP 프로토콜 사용
- 메소드 이름은 `{동사}{명사}` 형식 (예: `createIssueCommmitBranch`)

## 데이터 전송

### 요청 처리
- `@ModelAttribute`를 사용하여 멀티파트 폼 데이터 바인딩
- 요청 객체는 항상 도메인별 단일 `Request` 클래스 사용 (예: `NoticeRequest`, `StudyRequest`)
- 여러 엔드포인트의 다양한 데이터를 하나의 Request 클래스로 통합 관리
- 필수 파라미터는 HTML form에서 `required` 속성 추가하여 클라이언트 측 유효성 검사 구현

### 응답 처리
- `ResponseEntity<T>`를 사용하여 HTTP 상태 코드와 응답 본문 반환
- 응답 객체는 항상 도메인별 단일 `Response` 클래스 사용 (예: `NoticeResponse`)
- 다양한 응답 데이터를 내부 DTO 클래스를 통해 캡슐화
- 내부 DTO는 명확한 목적을 가진 클래스명 사용 (예: `NoticeCommentDto`)
- 응답 상태는 별도 필드(`success`, `message` 등)가 아닌 HTTP 상태 코드로만 표현
- 성공/실패 메시지는 프론트엔드에서 처리하며 백엔드 응답에 포함하지 않음

## 예외 처리
### 예외 처리 구조
- 예외 처리는 `util.exception` 패키지에 정의된 클래스들을 통해 일관되게 처리
- `CustomException`은 비즈니스 로직에서 발생하는 모든 예외를 표현하는 데 사용
- `ErrorCode` enum을 통해 예외 유형과 메시지, HTTP 상태 코드를 정의
- `GlobalExceptionHandler`에서 모든 예외를 중앙 집중적으로 처리

### 서비스 및 유틸리티에서의 예외 처리
- 비즈니스 로직에서는 `CustomException`을 사용하여 명확한 오류 코드와 메시지 제공
- 예외 발생 전에는 항상 로그 기록 (로그 레벨은 오류 심각도에 맞게 선택)
- 일반 예외(IOException, RuntimeException 등)를 그대로 전파하지 말고 `CustomException`으로 변환
- 도메인별 구체적인 오류 코드를 사용하여 디버깅 효율성 높이기

### ErrorCode 정의
- 모든 오류 코드는 `ErrorCode` enum에 정의
- 각 에러 코드는 적절한 HTTP 상태 코드와 한글 오류 메시지를 포함
- 오류 코드는 도메인별로 그룹화하여 주석으로 구분 (예: `// COMMON`, `// GITHUB`, `// NOTICE`, `// STUDY` 등)
- 오류 코드 명명 규칙: `{도메인}_{오류유형}` 형식 (예: `GITHUB_REPOSITORY_NOT_FOUND`, `STUDY_POST_NOT_FOUND`)
- 도메인별 오류 코드는 해당 도메인의 특성을 반영하여 최대한 상세하게 정의 (예: `GITHUB_ISSUE_URL_INVALID`, `STUDY_INVALID_REQUEST_PARAMETER` 등)
- 일반적인 오류는 COMMON 그룹에 정의 (예: `INTERNAL_SERVER_ERROR`, `INVALID_PARAMETER` 등)
- 리소스 관련 오류는 구체적인 리소스 이름을 포함하여 정의 (예: `POST_NOT_FOUND`, `CATEGORIES_NOT_FOUND`)

### 로깅 규칙
- 모든 예외는 반드시 로깅
- 오류 로깅은 한글 메시지와 함께 구체적인 내용 기록
- `log.error("서비스 오류: {}", e.getMessage(), e)` 형식으로 원인 예외도 함께 기록

## 로깅
- 모든 컨트롤러 클래스에 `@Slf4j` 애노테이션 사용
- 모든 Controller에는 `@LogMonitoringInvocation` 적용
- 오류 로깅은 한글 메시지와 함께 명확하게 기록 (예: `입력 오류: {}`)

## 의존성 주입
- 생성자 주입 방식 사용을 위해 `@RequiredArgsConstructor` 활용
- 필드에는 `final` 키워드 사용

## UI 디자인 가이드라인

### CSS 구조화
- 모든 스타일은 `common.css` 파일에 통합하여 관리
- CSS는 섹션별로 명확히 구분하여 정리 (주석으로 섹션 표시)
- 페이지별로 스타일을 그룹화하여 관리 (예: `.dashboard-page`, `.translator-page`, `.study-page`)
- 인라인 스타일은 절대 사용하지 않음 - 모든 스타일은 외부 CSS 파일에서 관리
- 각 기능별 CSS는 개별 파일로 분리하지 않고 common.css에 통합하여 중복을 방지

### CSS 네이밍 컨벤션
- 클래스명은 기능이나 목적을 명확히 표현하는 의미론적 이름 사용
- 컴포넌트별 클래스명은 `{페이지}-{컴포넌트}` 형식으로 명명 (예: `dashboard-section-header`)
- 공통 컴포넌트는 페이지 접두사 없이 명명 (예: `equal-height-card`)
- UI 프레임워크(Semantic UI) 클래스와 커스텀 클래스를 적절히 조합하여 사용

### 카드 컴포넌트
- 카드는 `ui fluid card equal-height-card` 클래스를 기본으로 사용
- 각 카드는 헤더, 설명, 액션 영역으로 구성
- 카드 배치는 4열 그리드를 기본으로 하되, 반응형으로 조정 (doubling stackable grid)
- 카드 크기를 일관되게 유지하기 위해 flex 속성 사용
- 모든 카드는 호버 효과 적용 (그림자, 상승 효과)

### 프로젝트 리소스 링크
- 각 프로젝트별로 관련 리소스(문서, 디자인 등) 링크는 명확한 아이콘과 함께 제공
- Figma 디자인 링크는 `figma-logo` 클래스를 가진 이미지 요소 사용
- Test/Prod 환경에 대한 링크는 명확하게 구분하여 표시 (Test), (Prod) 표기
- 모든 링크는 `target="_blank"` 속성을 추가하여 새 탭에서 열리도록 설정

### 버튼 스타일
- 바로가기 버튼은 `ui blue fluid button shortcut-btn` 클래스로 통일
- 버튼 내 텍스트는 가운데 정렬, 아이콘은 왼쪽에 배치
- 버튼 높이는 일관되게 유지 (40px)
- 비활성화된 링크는 회색 버튼(`ui grey fluid button`)으로 표시

### UI 효과 및 애니메이션
- 페이지 로딩 시 스켈레톤 UI 제공
- 스켈레톤 UI는 실제 콘텐츠와 같은 구조로 미리 제공
- 애니메이션 효과는 선형 그래디언트 슬라이딩 사용
- 호버 효과와 트랜지션은 부드러운 사용자 경험을 위해 적용

### 반응형 디자인
- 모든 페이지는 반응형으로 구현 (모바일, 태블릿, 데스크탑)
- 반응형 분기점: 모바일(~767px), 태블릿(768px~991px), 데스크탑(992px~)
- 모바일 환경에서는 컴포넌트 크기와 여백 축소, 그리드 조정
- 미디어 쿼리를 사용하여 화면 크기별 최적화 스타일 적용

### CSP(Content Security Policy) 준수
- 인라인 스타일 대신 CSS 클래스 사용 (예: `style="display: none"` 대신 `.hide` 클래스 사용)
- 인라인 JavaScript 이벤트 핸들러 대신 addEventListener 사용
- DOM 조작 시 innerHTML 대신 textContent, classList 등의 안전한 API 사용
- 동적 스타일 변경은 classList.add/remove를 통해 구현

### HTML 주석 스타일
- 주요 컴포넌트 블록에는 시작 부분에 주석으로 설명 추가
- 주석은 `<!-- 컴포넌트명 - 간략한 설명 -->` 형식으로 작성
- 설명은 키워드 중심으로 간결하게 작성 (동사 최소화)
- 섹션 구분을 위한 주석은 명확한 구분선 사용 (예: `<!-- ======== 섹션명 ======== -->`)

### 스터디 모듈 UI 가이드라인
- 스터디 페이지는 `.study-page` 클래스를 기본으로 사용
- 카테고리 트리는 `.category-tree` 클래스로 구현
- 마크다운 에디터는 EasyMDE 라이브러리 사용하고 `.markdown-editor-container`로 감싸기
- 마크다운 뷰어는 marked.js와 highlight.js 사용하여 구현
- 파일 업로드는 드래그 앤 드롭 지원 (`.dropzone` 클래스 사용)
- 포스트 목록은 `.posts-section` 클래스로 구현
- 카테고리 관리 페이지는 `.category-management-page` 클래스 사용

### 공지사항 UI 가이드라인
- 공지사항은 아코디언 컴포넌트를 사용하여 구현
- 기본적으로 모든 아코디언은 닫힌 상태로 시작 (`closeNested: true` 옵션 사용)
- 중요 공지사항은 상단에 배치하고 시각적으로 구분 (빨간색 라벨 또는 배경색 사용)
- 공지사항은 한 페이지에 최대 5개만 표시하고 페이지네이션 제공
- 페이지네이션은 미니 사이즈로 구현하여 UI를 해치지 않도록 함
- 아코디언 닫힌 상태에서 제목 옆에 작성자와 날짜 정보를 간결하게 표시

### 시간 표시 가이드라인
- 상대적 시간 표시는 `timeAgo` 함수를 사용하여 일관되게 구현
- 시간 표시 형식: "방금 전", "X분 전", "X시간 전", "X일 전", "X주 전", "X개월 전", "X년 전"
- 상세 정보에서는 정확한 날짜와 시간 표시 (예: `toLocaleString()` 사용)
- 모바일 환경에서는 날짜 표시를 더 간결하게 조정
- 시간 관련 정보는 항상 적절한 아이콘과 함께 표시 (예: 캘린더 아이콘)

### 컨테이너 로그 UI 가이드라인
- 로그 화면은 터미널 스타일로 구현 (어두운 배경에 밝은 텍스트)
- 로그 출력에는 Atom One Dark 또는 Monokai 테마 사용 (`highlight.js` 라이브러리 활용)
- 로그 출력 영역은 고정 높이 (viewport 높이의 60~70%)로 설정하고 스크롤 가능하게 구현
- 라인 수 제한 기능 구현 (옵션: 100, 500, 1000, 무제한)
- 자동 스크롤 토글 기능 제공 (최신 로그가 추가될 때 자동으로 맨 아래로 스크롤)
- 로그 타입 별로 색상 분류 (에러: 빨간색, 경고: 주황색, 정보: 녹색)
- 로그 스트리밍 상태를 표시하는 상태 인디케이터 제공 (연결 중, 스트리밍 중, 중지됨, 오류)
- 로그 행 수를 표시하는 카운터 제공
- 컨테이너 이름 입력 필드와 로그 시작/중지/초기화 버튼으로 구성된 컨트롤 패널 배치
- SSE(Server-Sent Events)를 사용하여 서버에서 로그를 실시간으로 푸시 받는 구현
- 하트비트 메시지를 통한 연결 상태 모니터링 (30초마다 서버에서 신호 전송)

### 댓글 UI 가이드라인
- 공지사항 아코디언 확장 시 하단에 댓글 섹션 표시
- 댓글 목록은 최신순으로 정렬하여 표시
- 댓글 작성자 이름과 익명화된 IP 주소 표시 (예: 123.456.78.9.x)
- 댓글에는 작성 일시와 내용, 삭제 버튼 포함
- 댓글 입력 폼은 작성자명 입력 필드와 내용 입력 필드로 구성
- 댓글 입력 폼은 간결하고 사용하기 쉽게 디자인
- 댓글 최대 표시 개수는 한 페이지에 200개로 제한하고 그 이상은 페이지네이션 제공
- 댓글 목록은 스크롤 가능한 컨테이너 내에 표시하여 공간 활용 최적화

## 중요!! (해당 부분은 삭제금지, 항상 맨 아래 유지)
- 항상 답변하기전에 너가 내가 말한것에 대한 전체적인 Plan을 먼저 짜고 해당 Task에 대해서 잘 처리해줘
- 해당 파일을 참고하면서 계속 나의 답변을 해주는데 내가 요구하는 내용과 이 md에 적혀있는 내용이 다르거나, 나중에 내가말하는 부분을 또 참고하면 좋은듯한 내용은 알아서 
코드스타일_가이드라인.md 이 파일에 추가해서 이어서 적어줘 , 지우고 최적화해도돼. 이 파일을 너가 답변을 잘하게 위해 있는 파일이야. 의미없는 내용은 지우고 참고하면 좋을만한 내용을 잘 참고해서 추가로 작성해줘

### Docker 로그 스트리밍 가이드 (Backend & Frontend 최소 체크리스트)
- 초기 **최근 N줄** 로그: `SshCommandExecutor.executeCommandWithSudoStdin()` 활용해 한 번에 문자열 수신 후 SSE로 전송.
- 실시간 스트림: JSch 채널 사용, 명령형식
  `echo "<PW>" | sudo -S bash -c 'export PATH=$PATH:/usr/local/bin && docker logs -f <CONTAINER>'`
  + `channel.setPty(true)` 필수 – PTY 없으면 스트림이 조기 종료될 수 있음.
- SSE 전송 시 `IllegalStateException (Emitter closed)` 발생 가능 → try/catch 로 무시하거나 루프 종료.
- 클라이언트 중지 요청은 **FormData (multipart/form-data)** 로 전송해야 컨트롤러가 매핑됨.
- 프론트 JS: 연결/해제/에러 `console.log()` 최소 로그 남겨 디버깅 용이하게.